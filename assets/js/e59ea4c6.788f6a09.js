"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[866],{3905:(e,n,t)=>{t.d(n,{Zo:()=>d,kt:()=>u});var a=t(7294);function r(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function o(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);n&&(a=a.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,a)}return t}function i(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?o(Object(t),!0).forEach((function(n){r(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):o(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function l(e,n){if(null==e)return{};var t,a,r=function(e,n){if(null==e)return{};var t,a,r={},o=Object.keys(e);for(a=0;a<o.length;a++)t=o[a],n.indexOf(t)>=0||(r[t]=e[t]);return r}(e,n);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(a=0;a<o.length;a++)t=o[a],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(r[t]=e[t])}return r}var s=a.createContext({}),c=function(e){var n=a.useContext(s),t=n;return e&&(t="function"==typeof e?e(n):i(i({},n),e)),t},d=function(e){var n=c(e.components);return a.createElement(s.Provider,{value:n},e.children)},p="mdxType",m={inlineCode:"code",wrapper:function(e){var n=e.children;return a.createElement(a.Fragment,{},n)}},h=a.forwardRef((function(e,n){var t=e.components,r=e.mdxType,o=e.originalType,s=e.parentName,d=l(e,["components","mdxType","originalType","parentName"]),p=c(t),h=r,u=p["".concat(s,".").concat(h)]||p[h]||m[h]||o;return t?a.createElement(u,i(i({ref:n},d),{},{components:t})):a.createElement(u,i({ref:n},d))}));function u(e,n){var t=arguments,r=n&&n.mdxType;if("string"==typeof e||r){var o=t.length,i=new Array(o);i[0]=h;var l={};for(var s in n)hasOwnProperty.call(n,s)&&(l[s]=n[s]);l.originalType=e,l[p]="string"==typeof e?e:r,i[1]=l;for(var c=2;c<o;c++)i[c]=t[c];return a.createElement.apply(null,i)}return a.createElement.apply(null,t)}h.displayName="MDXCreateElement"},4548:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>s,contentTitle:()=>i,default:()=>p,frontMatter:()=>o,metadata:()=>l,toc:()=>c});var a=t(7462),r=(t(7294),t(3905));const o={},i="Channels",l={unversionedId:"coding-guides/channels",id:"coding-guides/channels",title:"Channels",description:"Overview",source:"@site/docs/coding-guides/channels.md",sourceDirName:"coding-guides",slug:"/coding-guides/channels",permalink:"/coding-guides/channels",draft:!1,tags:[],version:"current",frontMatter:{},sidebar:"docsSidebar",previous:{title:"Resources",permalink:"/coding-guides/resources"},next:{title:"Extensions",permalink:"/coding-guides/extensions"}},s={},c=[{value:"Overview",id:"overview",level:2},{value:"Using Channels",id:"using-channels",level:2},{value:"Platform Adapter",id:"platform-adapter",level:2},{value:"Receivers and Senders",id:"receivers-and-senders",level:2},{value:"Mixins",id:"mixins",level:2},{value:"Adding Channels",id:"adding-channels",level:2},{value:"Extending channels",id:"extending-channels",level:2},{value:"Custom Receivers",id:"custom-receivers",level:3},{value:"Custom senders",id:"custom-senders",level:3}],d={toc:c};function p(e){let{components:n,...t}=e;return(0,r.kt)("wrapper",(0,a.Z)({},d,t,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"channels"},"Channels"),(0,r.kt)("h2",{id:"overview"},"Overview"),(0,r.kt)("p",null,"Channels are an abstractions for messaging platforms which connect your bot to the intended user. There are a lot of such platforms: Telegram, Facebook Messenger and more."),(0,r.kt)("p",null,"Another purpose of channels is to provide implementations for conversatinoal applications. (TODO: link to applications)"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"maxbot")," provides pre-built channels for the many famous platforms. (TODO: link to the list)"),(0,r.kt)("h2",{id:"using-channels"},"Using Channels"),(0,r.kt)("p",null,"For each platform, there is a channel class that derives from the abstract ",(0,r.kt)("inlineCode",{parentName:"p"},"Channel"),". A bot can use one or more channels to interact with the user. The channel class instance is implicitly created when a channel configuration is added to bot resources."),(0,r.kt)("p",null,"Currently, the only thing you can do directly with a channel instance is run a channel-specific application. This can be done by calling a channel method like ",(0,r.kt)("inlineCode",{parentName:"p"},"run_something")," where ",(0,r.kt)("inlineCode",{parentName:"p"},"something")," is the application type."),(0,r.kt)("p",null,"The example shows you how to setup and run simple conversational application for ",(0,r.kt)("a",{parentName:"p",href:"https://core.telegram.org/bots/"},"Telegram Bots")," platform. In the example we use builtin Telegram channel."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},'from maxbot import MaxBot\n\nbot = MaxBot.inline("""\n    channels:\n        telegram:\n            api_token: !ENV ${TELEGRAM_API_KEY}\n    dialog:\n      - condition: message.text == \'hello\'\n        response: Good day to you!\n""")\n\nbot.telegram.run_ptb_polling()\n')),(0,r.kt)("p",null,"We use the ",(0,r.kt)("inlineCode",{parentName:"p"},"bot.telegram")," attriburte to refer the channel instance."),(0,r.kt)("p",null,"The ",(0,r.kt)("inlineCode",{parentName:"p"},"run_ptb_polling")," method runs the conversational app based on the channel-specific polling implementation. Internally it uses the platform adapter to process telegram messages."),(0,r.kt)("h2",{id:"platform-adapter"},"Platform Adapter"),(0,r.kt)("p",null,"In order to create your own and extend existing channels, it is important to understand how they allow the bot to abstract from real world platforms."),(0,r.kt)("p",null,"Channel classes are used to hide the details of platform-specific protocols and APIs and represent the communication process in platform-independent structures such as dialog information, message and command."),(0,r.kt)("p",null,"The platform adapter pattern looks like this:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"dialog = channel.create_dialog(**chargs)\nmessage = channel.call_receivers(**chargs)\nfor command in bot.process_message(message, dialog):\n    channel.call_senders(command, dialog, **chargs)\n")),(0,r.kt)("p",null,"Where ",(0,r.kt)("inlineCode",{parentName:"p"},"chargs")," are platform-specific channel arguments of two types:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"the incoming data such as user sended messages and information about users themself;"),(0,r.kt)("li",{parentName:"ul"},"the gateway that used to communicate with platform API.")),(0,r.kt)("p",null,"The code snippet above do the following."),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"The platform-independent dialog information and message structures are created by the channel from the plarform-specific incoming data."),(0,r.kt)("li",{parentName:"ul"},"These structures are processed by the bot, which returns a list of commands."),(0,r.kt)("li",{parentName:"ul"},"Platform-independent commands are sended as a response to the user by the channel using the platform-specific gateway.")),(0,r.kt)("h2",{id:"receivers-and-senders"},"Receivers and Senders"),(0,r.kt)("p",null,"The ",(0,r.kt)("inlineCode",{parentName:"p"},"Channel.call_receivers")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"Channel.call_senders")," methods internally use hooks called senders and receivers. These hooks are used to receive messages and send commands of different types. A channel class discover its hooks among its members using a naming convention: the ",(0,r.kt)("inlineCode",{parentName:"p"},"receive_")," or ",(0,r.kt)("inlineCode",{parentName:"p"},"send_")," prefix followed by the message or command type."),(0,r.kt)("h2",{id:"mixins"},"Mixins"),(0,r.kt)("p",null,"It's easy to create new and extend existing channels thanks to the mixins technique based on Python's multiple inheritance."),(0,r.kt)("p",null,"The particular channel class is created at run time and does not contain any methods itself. It inherits the abstract ",(0,r.kt)("inlineCode",{parentName:"p"},"Channel")," class and multiple mixin classes. Mixins implement all the necessary methods. They can be added using the ",(0,r.kt)("inlineCode",{parentName:"p"},"BotBuilder.add_channel_mixin")," method or the ",(0,r.kt)("inlineCode",{parentName:"p"},"BotBuilder.channel_mixin")," decorator. A channel method can be implemented in more than one mixin. The actual implementation is chosen based on the ",(0,r.kt)("a",{parentName:"p",href:"https://docs.python.org/3/tutorial/classes.html#multiple-inheritance"},"multiple inheritance")," rules."),(0,r.kt)("p",null,"Mixins are added to the list of base classes from right to left. The abstract class ",(0,r.kt)("inlineCode",{parentName:"p"},"Channel")," is rightmost. For example, let's create a channel using a couple of mixins."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"builder.add_channel_mixin(MyChannel1, 'my_channel')\nbuilder.add_channel_mixin(MyChannel2, 'my_channel')\n")),(0,r.kt)("p",null,"The generated class will look like this."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"class GeneratedChannel_MyChannel(MyChannel2, MyChannel1, Channel):\n    pass\n")),(0,r.kt)("p",null,"Thus, any channel method is searched for in ",(0,r.kt)("inlineCode",{parentName:"p"},"MyChannel2"),", then in ",(0,r.kt)("inlineCode",{parentName:"p"},"MyChannel1"),", and then in ",(0,r.kt)("inlineCode",{parentName:"p"},"Channel"),"."),(0,r.kt)("h2",{id:"adding-channels"},"Adding Channels"),(0,r.kt)("p",null,"To create a channel, you need to create a mixin that implements at least all the abstract methods of the ",(0,r.kt)("inlineCode",{parentName:"p"},"Channel")," class and register it using the ",(0,r.kt)("inlineCode",{parentName:"p"},"BotBuilder.channel_mixin")," with the desired name."),(0,r.kt)("p",null,'In the example we will create a simple "repl" channel that will allow us to communicate with the bot through an interactive shell.'),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"from marshmallow import fields, Schema\nfrom maxbot import MaxBot, Channel\n\nbuilder = MaxBot.builder()\n\n@builder.channel_mixin(\"repl\")\nclass ReplChannel(Channel):\n    class ConfigSchema(Schema):\n        user_prompt = fields.String(load_default='User')\n        bot_prompt = fields.String(load_default=' Bot')\n\n    def create_dialog(self, text, user_id):\n        return {'channel_name': 'cli', 'user_id': user_id}\n\n    def receive_text(self, text, user_id):\n        return {'text': text}\n\n    def send_text(self, command, dialog):\n        print(self.config[\"bot_prompt\"] + \":\", command[\"text\"])\n\n    def run_interactive(self):\n        while True:\n            # Getting platform-specific channel arguments\n            text = input(self.config[\"user_prompt\"] + \": \")\n            user_id = 'John' # TODO: add some kind of authorization\n\n              # Running simple platform adapter\n            self.simple_adapter(text=text, user_id=1)\n\nbuilder.use_inline_resources(\"\"\"\n    channels:\n        repl:\n            user_prompt: \ud83e\uddd1\n            bot_prompt: \ud83e\udd16\n    dialog:\n      - condition: message.text in ['hello', 'hi']\n        response: Good day to you!\n      - condition: message.text in ['good bye', 'bye']\n        response: OK. See you later.\n      - condition: true\n        response: Sorry I don\"t understand.\n\"\"\")\nbot = builder.build()\nbot.repl.run_interactive()\n")),(0,r.kt)("p",null,"In the example above we have implemented:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"configuration schema for prompt strings for the bot and users;"),(0,r.kt)("li",{parentName:"ul"},"three abstract methods of the ",(0,r.kt)("inlineCode",{parentName:"li"},"Channel")," class: ",(0,r.kt)("inlineCode",{parentName:"li"},"create_dialog")," and a minimal set of mandatory hooks ",(0,r.kt)("inlineCode",{parentName:"li"},"receive_text")," and ",(0,r.kt)("inlineCode",{parentName:"li"},"send_text"),";"),(0,r.kt)("li",{parentName:"ul"},"the ",(0,r.kt)("inlineCode",{parentName:"li"},"run_interactive")," method which runs the channel-specific conversational application as a ",(0,r.kt)("a",{parentName:"li",href:"https://en.wikipedia.org/wiki/Read%E2%80%93eval%E2%80%93print_loop"},"read\u2013eval\u2013print")," loop, it uses the ",(0,r.kt)("inlineCode",{parentName:"li"},"Channel.simple_adapter")," wich is the simplest implementation of the platform adapter pattern.")),(0,r.kt)("h2",{id:"extending-channels"},"Extending channels"),(0,r.kt)("p",null,"To extend a channel you need to create an additional mixin with the methods you wish to add or overwrite and register it with the channel name."),(0,r.kt)("h3",{id:"custom-receivers"},"Custom Receivers"),(0,r.kt)("p",null,"When you add a custom message to your bot you also need to add a message receiver for each of channels used in your application. In this example we'll add the custom message that represents a phone contact and message receiver for the pre-built Telegram channel."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},'from marshmallow import fields, Schema\nfrom maxbot import MaxBot\nfrom telegram import Update, Bot\n\nbuilder = MaxBot.builder()\n\n@builder.message("contact")\nclass ContactMessage(Schema):\n    phone_number = fields.String(required=True)\n    name = fields.String()\n\n@builder.channel_mixin("telegram")\nclass TelegramContact:\n\n    def receive_contact(self, update: Update, bot: Bot):\n        """\n            @see https://core.telegram.org/bots/api#contact\n        """\n        if update.message.contact:\n            contact = update.message.contact\n            return {\'contact\': {\n                \'phone_number\': contact.phone_number,\n                \'name\': contact.first_name\n            }}\n\nbuilder.use_inline_resources("""\n    channels:\n        telegram:\n            api_token: !ENV ${TELEGRAM_API_KEY}\n    dialog:\n      - condition: message.contact\n        response: !jinja "Received {{ message.contact.phone_number }}"\n""")\nbot = builder.build()\nbot.telegram.run_ptb_polling()\n')),(0,r.kt)("h3",{id:"custom-senders"},"Custom senders"),(0,r.kt)("p",null,"When you add a custom command to your bot you also need to add a command sender for each of channels used in your application. In this example we'll add the custom command that represents a location on the map and command sender for the pre-built Telegram channel."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},'from marshmallow import fields, Schema\nfrom maxbot import MaxBot\nfrom telegram import Bot\n\nbuilder = MaxBot.builder()\n\n@builder.command("location")\nclass LocationCommand(Schema):\n    longitude = fields.Float(required=True)\n    latitude = fields.Float(required=True)\n\n@builder.channel_mixin("telegram")\nclass TelegramLocation:\n    def send_location(self, command, channel, bot: Bot):\n        """\n            @see https://core.telegram.org/bots/api#sendlocation\n        """\n        location = command["location"]\n        bot.send_location(\n            channel[\'user_id\'],\n            latitude=location["latitude"],\n            longitude=location["longitude"],\n        )\n\nbuilder.use_inline_resources("""\n    channels:\n        telegram:\n            api_token: !ENV ${TELEGRAM_API_KEY}\n    dialog:\n      - condition: message.text == "Where are you?"\n        response:\n          - text: I am here!\n          - location: {latitude: 40.7580, longitude: -73.9855}\n""")\nbot = builder.build()\nbot.telegram.run_ptb_polling()\n')))}p.isMDXComponent=!0}}]);